package lexer;
import java_cup.runtime.Symbol;
import arbolSintactico.arbol;
import java.util.HashMap;
import java.util.Map;
import util.AnalizadorSemantico;


/* =========================
   TERMINALES (TOKENS)
   ========================= */
terminal MAIN, GIFT;

terminal WORLD, LOCAL, ENDL;
terminal T_INT, T_FLOAT, T_BOOL, T_CHAR, T_STRING, T_COAL;

terminal IDENT, INT_LIT, FLOAT_LIT, BOOL_LIT, CHAR_LIT, STRING_LIT;

terminal IGUAL, SUMA, RESTA, MULTIPLICACION, DIVISION, INTDIV, MODULO, POTENCIA;
terminal INC, DEC;

terminal LT, LE, GT, GE, EQ, NEQ;
terminal AND, OR, NOT;
terminal ARROW;

terminal PARENTizq, PARENder, CORCHizq, CORCHder, COMA;
terminal BLOQAB, BLOQCR;

terminal DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, RETURN, BREAK;

/* =========================
   NO TERMINALES (arbol)
   ========================= */
non terminal arbol program;

non terminal arbol lista_globales, decl_global;
non terminal arbol lista_funciones, funcion, params, lista_params;
non terminal arbol navidad_decl;

non terminal arbol bloque_bloq;
non terminal arbol stmt_list, stmt;

non terminal arbol tipo_base;
non terminal arbol dims2d_opt;

non terminal arbol decl_local;
non terminal arbol asignacion;

non terminal arbol expr, expr_or, expr_and, expr_eq, expr_rel, expr_suma, expr_mult, expr_pot, expr_un, prim;
non terminal arbol llamada, args, lista_args;

non terminal arbol arr_access, arr_init, lista_filas, fila, lista_elems;

non terminal arbol decide_stmt, decide_casos, decide_caso;
non terminal arbol loop_stmt;

/* =========================
   PRECEDENCIAS
   ========================= */
precedence right IGUAL;
precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, INTDIV, MODULO;
precedence right POTENCIA;
precedence right NOT;
precedence right INC, DEC;

start with program;







/* =========================
   PRODUCCIONES
   ========================= */

/* Programa: globales* funciones* navidad */
program ::= lista_globales:lg lista_funciones:lf navidad_decl:nd
          {: arbol nodo = new arbol("PROGRAM");
             if (lg != null) nodo.agregarHijo(lg);
             if (lf != null) nodo.agregarHijo(lf);
             nodo.agregarHijo(nd);
             AnalizadorSemantico.limpiar();
             RESULT = nodo; :}
          ;

/* -------- Globales (world) -------- */
lista_globales ::= /* empty */
                 {: RESULT = null; :}
                 | lista_globales:lg decl_global:dg
                 {: arbol nodo = (lg != null) ? lg : new arbol("GLOBALES");
                    nodo.agregarHijo(dg);
                    RESULT = nodo; :}
                 | lista_globales:lg error ENDL
                 {: util.ErrorHandler.agregarErrorSintactico("Error en declaración global - se salta a siguiente línea");
                    RESULT = lg; :}
                 ;

/*
  world tipo id dims? endl
  world tipo id dims? = expr endl
  world tipo id dims? = arr_init endl
*/
decl_global ::= WORLD tipo_base:tb IDENT:id dims2d_opt ENDL
              {: arbol nodo = new arbol("DECL_GLOBAL", id.toString());
                 nodo.agregarHijo(tb);
                 // ANÁLISIS SEMÁNTICO: Registrar variable global
                 AnalizadorSemantico.registrarVariableGlobal(id.toString(), tb.valor);
                 RESULT = nodo; :}
              | WORLD tipo_base:tb IDENT:id dims2d_opt IGUAL expr:e ENDL
              {: arbol nodo = new arbol("DECL_GLOBAL", id.toString());
                 nodo.agregarHijo(tb);
                 nodo.agregarHijo(e);
                 // ANÁLISIS SEMÁNTICO: Registrar variable global y validar tipo
                 AnalizadorSemantico.registrarVariableGlobal(id.toString(), tb.valor);
                 String tipoExpr = AnalizadorSemantico.obtenerTipoExpresion(e);
                 AnalizadorSemantico.validarCompatibilidadTipos(tb.valor, tipoExpr, "=");
                 RESULT = nodo; :}
              | WORLD tipo_base:tb IDENT:id dims2d_opt IGUAL arr_init:ai ENDL
              {: arbol nodo = new arbol("DECL_GLOBAL", id.toString());
                 nodo.agregarHijo(tb);
                 nodo.agregarHijo(ai);
                 // ANÁLISIS SEMÁNTICO: Registrar variable global como arreglo
                 AnalizadorSemantico.registrarVariableGlobal(id.toString(), tb.valor + "[]");
                 RESULT = nodo; :}
              ;

/* -------- Funciones (gift) -------- */
lista_funciones ::= /* empty */
                  {: RESULT = null; :}
                  | lista_funciones:lf funcion:f
                  {: arbol nodo = (lf != null) ? lf : new arbol("FUNCIONES");
                     nodo.agregarHijo(f);
                     RESULT = nodo; :}
                  ;

funcion ::= GIFT tipo_base:tb IDENT:id PARENTizq params:p PARENder bloque_bloq:bb
          {: arbol nodo = new arbol("FUNCION", id.toString());
             nodo.agregarHijo(tb);
             if (p != null) nodo.agregarHijo(p);
             nodo.agregarHijo(bb);
             // ANÁLISIS SEMÁNTICO: Registrar función con su tipo de retorno
             AnalizadorSemantico.registrarFuncion(id.toString(), tb.valor);
             RESULT = nodo; :}
          ;

params ::= /* empty */
         {: RESULT = null; :}
         | lista_params:lp
         {: RESULT = lp; :}
         ;

lista_params ::= tipo_base:tb IDENT:id
               {: arbol nodo = new arbol("PARAMETROS");
                  arbol param = new arbol("PARAM", id.toString());
                  param.agregarHijo(tb);
                  nodo.agregarHijo(param);
                  RESULT = nodo; :}
               | lista_params:lp COMA tipo_base:tb IDENT:id
               {: arbol param = new arbol("PARAM", id.toString());
                  param.agregarHijo(tb);
                  lp.agregarHijo(param);
                  RESULT = lp; :}
               ;

navidad_decl ::= T_COAL MAIN PARENTizq PARENder bloque_bloq:bb
               {: arbol nodo = new arbol("MAIN", "navidad");
                  nodo.agregarHijo(bb);
                  RESULT = nodo; :}
               ;

/* -------- Tipos -------- */
tipo_base ::= T_INT    {: RESULT = new arbol("TIPO", "int"); :}
            | T_FLOAT  {: RESULT = new arbol("TIPO", "float"); :}
            | T_BOOL   {: RESULT = new arbol("TIPO", "bool"); :}
            | T_CHAR   {: RESULT = new arbol("TIPO", "char"); :}
            | T_STRING {: RESULT = new arbol("TIPO", "string"); :}
            ;

/* -------- Dimensiones opcionales 2D -------- */
dims2d_opt ::= /* empty */
             {: RESULT = null; :}
             | CORCHizq INT_LIT:n1 CORCHder CORCHizq INT_LIT:n2 CORCHder
             {: arbol nodo = new arbol("DIMS", n1.toString() + "x" + n2.toString());
                RESULT = nodo; :}
             ;

/* -------- Arreglos: acceso e init -------- */
arr_access ::= IDENT:id CORCHizq expr:e1 CORCHder CORCHizq expr:e2 CORCHder
             {: arbol nodo = new arbol("ARRAY_ACCESS", id.toString());
                nodo.agregarHijo(e1);
                nodo.agregarHijo(e2);
                // ANÁLISIS SEMÁNTICO: Validar que la variable esté declarada
                if (!AnalizadorSemantico.estaVariableDeclara(id.toString())) {
                   util.ErrorHandler.agregarErrorSemantico("Variable no declarada: " + id.toString());
                }
                // Validar que los índices sean enteros
                String tipoIdx1 = AnalizadorSemantico.obtenerTipoExpresion(e1);
                String tipoIdx2 = AnalizadorSemantico.obtenerTipoExpresion(e2);
                if (!tipoIdx1.equals("int")) {
                   util.ErrorHandler.agregarErrorSemantico("Índice de arreglo debe ser entero, se recibió " + tipoIdx1);
                }
                if (!tipoIdx2.equals("int")) {
                   util.ErrorHandler.agregarErrorSemantico("Índice de arreglo debe ser entero, se recibió " + tipoIdx2);
                }
                RESULT = nodo; :}
             ;

/* init con ¡ ... ! como matriz: ¡ ¡a,b! , ¡c,d! ! */
arr_init ::= BLOQAB lista_filas:lf BLOQCR
           {: arbol nodo = new arbol("ARRAY_INIT");
              nodo.agregarHijo(lf);
              RESULT = nodo; :}
           ;

lista_filas ::= fila:f
              {: arbol nodo = new arbol("FILAS");
                 nodo.agregarHijo(f);
                 RESULT = nodo; :}
              | lista_filas:lf COMA fila:f
              {: lf.agregarHijo(f);
                 RESULT = lf; :}
              ;

fila ::= BLOQAB lista_elems:le BLOQCR
       {: arbol nodo = new arbol("FILA");
          nodo.agregarHijo(le);
          RESULT = nodo; :}
       ;

lista_elems ::= expr:e
              {: arbol nodo = new arbol("ELEMENTOS");
                 nodo.agregarHijo(e);
                 RESULT = nodo; :}
              | lista_elems:le COMA expr:e
              {: le.agregarHijo(e);
                 RESULT = le; :}
              ;

/* -------- Bloques -------- */
bloque_bloq ::= BLOQAB stmt_list:sl BLOQCR
              {: arbol nodo = new arbol("BLOQUE");
                 if (sl != null) nodo.agregarHijo(sl);
                 RESULT = nodo; :}
              ;

/* ------------ actualizacion con error -----------*/
stmt_list ::= /* empty */
            {: RESULT = null; :}
            | stmt_list:sl stmt:s
            {: arbol nodo = (sl != null) ? sl : new arbol("SENTENCIAS");
               nodo.agregarHijo(s);
               RESULT = nodo; :}
            | stmt_list:sl error ENDL
            {: util.ErrorHandler.agregarErrorSintactico("Error sintáctico en línea: se esperaba una sentencia válida");
               RESULT = sl; :}
            ;

/* -------- Sentencias (endl termina) -------- */
stmt ::= decl_local:dl ENDL
       {: RESULT = dl; :}
       | asignacion:a ENDL
       {: RESULT = a; :}
       | expr:e ENDL
       {: RESULT = e; :}
       | RETURN expr:e ENDL
       {: arbol nodo = new arbol("RETURN");
          nodo.agregarHijo(e);
          RESULT = nodo; :}
       | BREAK ENDL
       {: RESULT = new arbol("BREAK"); :}
       | decide_stmt:ds
       {: RESULT = ds; :}
       | loop_stmt:ls
       {: RESULT = ls; :}
       | FOR PARENTizq asignacion:a1 ENDL expr:e ENDL expr:e2 PARENder bloque_bloq:bb
       {: arbol nodo = new arbol("FOR");
          nodo.agregarHijo(a1);
          nodo.agregarHijo(e);
          nodo.agregarHijo(e2);
          nodo.agregarHijo(bb);
          RESULT = nodo; :}
       ;

/* local tipo id dims? (= expr | = arr_init)? */
decl_local ::= LOCAL tipo_base:tb IDENT:id dims2d_opt
             {: arbol nodo = new arbol("DECL_LOCAL", id.toString());
                nodo.agregarHijo(tb);
                // ANÁLISIS SEMÁNTICO: Registrar variable local
                AnalizadorSemantico.registrarVariableLocal(id.toString(), tb.valor);
                RESULT = nodo; :}
             | LOCAL tipo_base:tb IDENT:id dims2d_opt IGUAL expr:e
             {: arbol nodo = new arbol("DECL_LOCAL", id.toString());
                nodo.agregarHijo(tb);
                nodo.agregarHijo(e);
                // ANÁLISIS SEMÁNTICO: Registrar variable local y validar tipo
                AnalizadorSemantico.registrarVariableLocal(id.toString(), tb.valor);
                String tipoExpr = AnalizadorSemantico.obtenerTipoExpresion(e);
                AnalizadorSemantico.validarCompatibilidadTipos(tb.valor, tipoExpr, "=");
                RESULT = nodo; :}
             | LOCAL tipo_base:tb IDENT:id dims2d_opt IGUAL arr_init:ai
             {: arbol nodo = new arbol("DECL_LOCAL", id.toString());
                nodo.agregarHijo(tb);
                nodo.agregarHijo(ai);
                // ANÁLISIS SEMÁNTICO: Registrar variable local como arreglo
                AnalizadorSemantico.registrarVariableLocal(id.toString(), tb.valor + "[]");
                RESULT = nodo; :}
             ;

/* asignación: id = expr | A[i][j] = expr */
asignacion ::= IDENT:id IGUAL expr:e
             {: arbol nodo = new arbol("ASIGNACION", id.toString());
                nodo.agregarHijo(e);
                // ANÁLISIS SEMÁNTICO: Validar que la variable esté declarada
                if (!AnalizadorSemantico.estaVariableDeclara(id.toString())) {
                    util.ErrorHandler.agregarErrorSemantico("Variable no declarada: " + id.toString());
                }
            else {
               String tipoVar = AnalizadorSemantico.obtenerTipoVariable(id.toString());
               String tipoExpr = AnalizadorSemantico.obtenerTipoExpresion(e);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoVar, tipoExpr, "=");
            }
            RESULT = nodo; :}
             | arr_access:aa IGUAL expr:e
             {: arbol nodo = new arbol("ASIGNACION_ARRAY");
                nodo.agregarHijo(aa);
                nodo.agregarHijo(e);
                // ANÁLISIS SEMÁNTICO: Validación en arr_access
            // Validar tipo del elemento del arreglo
            if (aa != null && aa.valor != null) {
               String nombreVar = aa.valor;
               String tipoVar = AnalizadorSemantico.obtenerTipoVariable(nombreVar);
               if (tipoVar == null) {
                  util.ErrorHandler.agregarErrorSemantico("Variable de arreglo no declarada: " + nombreVar);
               } else {
                  // tipoVar esperado: e.g., "int[]"
                  String base = tipoVar.endsWith("[]") ? tipoVar.replace("[]", "") : tipoVar;
                  String tipoExpr = AnalizadorSemantico.obtenerTipoExpresion(e);
                  AnalizadorSemantico.validarCompatibilidadTipos(base, tipoExpr, "=");
               }
            }
            RESULT = nodo; :}
             ;

/* -------- decide of --------
decide of
 (¿ cond ? -> bloque)+
 (else -> bloque)?
end decide endl
*/
decide_stmt ::= DECIDE OF decide_casos:dc END DECIDE ENDL
              {: arbol nodo = new arbol("DECIDE");
                 nodo.agregarHijo(dc);
                 RESULT = nodo; :}
              | DECIDE OF decide_casos:dc ELSE ARROW bloque_bloq:bb END DECIDE ENDL
              {: arbol nodo = new arbol("DECIDE");
                 nodo.agregarHijo(dc);
                 arbol elseNodo = new arbol("ELSE");
                 elseNodo.agregarHijo(bb);
                 nodo.agregarHijo(elseNodo);
                 RESULT = nodo; :}
              ;

decide_casos ::= decide_caso:dc
               {: arbol nodo = new arbol("CASOS");
                  nodo.agregarHijo(dc);
                  RESULT = nodo; :}
               | decide_casos:dcs decide_caso:dc
               {: dcs.agregarHijo(dc);
                  RESULT = dcs; :}
               ;

decide_caso ::= PARENTizq expr:e PARENder ARROW bloque_bloq:bb
              {: arbol nodo = new arbol("CASO");
                 nodo.agregarHijo(e);
                 nodo.agregarHijo(bb);
                 RESULT = nodo; :}
              ;

/* -------- loop (Ada) --------
loop
  instrucciones...
  exit when condicion endl
end loop endl
*/
loop_stmt ::= LOOP stmt_list:sl EXIT WHEN expr:e ENDL END LOOP ENDL
            {: arbol nodo = new arbol("LOOP");
               if (sl != null) nodo.agregarHijo(sl);
               arbol salida = new arbol("EXIT");
               salida.agregarHijo(e);
               nodo.agregarHijo(salida);
               RESULT = nodo; :}
            ;

/* =========================
   EXPRESIONES (por niveles)
   ========================= */
expr ::= expr_or:eo
       {: RESULT = eo; :}
       ;

expr_or ::= expr_or:eo OR expr_and:ea
          {: arbol nodo = new arbol("OPERACION", "OR");
             nodo.agregarHijo(eo);
             nodo.agregarHijo(ea);
             // ANÁLISIS SEMÁNTICO: Validar tipos bool
             String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(eo);
             String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ea);
             AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "OR");
             RESULT = nodo; :}
          | expr_and:ea
          {: RESULT = ea; :}
          ;

expr_and ::= expr_and:ea AND expr_eq:ee
           {: arbol nodo = new arbol("OPERACION", "AND");
              nodo.agregarHijo(ea);
              nodo.agregarHijo(ee);
              // ANÁLISIS SEMÁNTICO: Validar tipos bool
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(ea);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ee);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "AND");
              RESULT = nodo; :}
           | expr_eq:ee
           {: RESULT = ee; :}
           ;

expr_eq ::= expr_eq:ee EQ expr_rel:er
          {: arbol nodo = new arbol("OPERACION", "==");
             nodo.agregarHijo(ee);
             nodo.agregarHijo(er);
             // ANÁLISIS SEMÁNTICO: Validar igualdad
             String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(ee);
             String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(er);
             AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "==");
             RESULT = nodo; :}
          | expr_eq:ee NEQ expr_rel:er
          {: arbol nodo = new arbol("OPERACION", "!=");
             nodo.agregarHijo(ee);
             nodo.agregarHijo(er);
             // ANÁLISIS SEMÁNTICO: Validar desigualdad
             String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(ee);
             String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(er);
             AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "!=");
             RESULT = nodo; :}
          | expr_rel:er
          {: RESULT = er; :}
          ;

expr_rel ::= expr_suma:es1 LT expr_suma:es2
           {: arbol nodo = new arbol("OPERACION", "<");
              nodo.agregarHijo(es1);
              nodo.agregarHijo(es2);
              // ANÁLISIS SEMÁNTICO: Validar tipos comparables
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es1);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(es2);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "<");
              RESULT = nodo; :}
           | expr_suma:es1 LE expr_suma:es2
           {: arbol nodo = new arbol("OPERACION", "<=");
              nodo.agregarHijo(es1);
              nodo.agregarHijo(es2);
              // ANÁLISIS SEMÁNTICO: Validar tipos comparables
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es1);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(es2);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "<=");
              RESULT = nodo; :}
           | expr_suma:es1 GT expr_suma:es2
           {: arbol nodo = new arbol("OPERACION", ">");
              nodo.agregarHijo(es1);
              nodo.agregarHijo(es2);
              // ANÁLISIS SEMÁNTICO: Validar tipos comparables
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es1);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(es2);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, ">");
              RESULT = nodo; :}
           | expr_suma:es1 GE expr_suma:es2
           {: arbol nodo = new arbol("OPERACION", ">=");
              nodo.agregarHijo(es1);
              nodo.agregarHijo(es2);
              // ANÁLISIS SEMÁNTICO: Validar tipos comparables
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es1);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(es2);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, ">=");
              RESULT = nodo; :}
           | expr_suma:es
           {: RESULT = es; :}
           ;

expr_suma ::= expr_suma:es SUMA expr_mult:em
            {: arbol nodo = new arbol("OPERACION", "+");
               nodo.agregarHijo(es);
               nodo.agregarHijo(em);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(em);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "+");
               RESULT = nodo; :}
            | expr_suma:es RESTA expr_mult:em
            {: arbol nodo = new arbol("OPERACION", "-");
               nodo.agregarHijo(es);
               nodo.agregarHijo(em);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(es);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(em);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "-");
               RESULT = nodo; :}
            | expr_mult:em
            {: RESULT = em; :}
            ;

expr_mult ::= expr_mult:em MULTIPLICACION expr_pot:ep
            {: arbol nodo = new arbol("OPERACION", "*");
               nodo.agregarHijo(em);
               nodo.agregarHijo(ep);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(em);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ep);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "*");
               RESULT = nodo; :}
            | expr_mult:em DIVISION expr_pot:ep
            {: arbol nodo = new arbol("OPERACION", "/");
               nodo.agregarHijo(em);
               nodo.agregarHijo(ep);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(em);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ep);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "/");
               RESULT = nodo; :}
            | expr_mult:em INTDIV expr_pot:ep
            {: arbol nodo = new arbol("OPERACION", "//");
               nodo.agregarHijo(em);
               nodo.agregarHijo(ep);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(em);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ep);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "//");
               RESULT = nodo; :}
            | expr_mult:em MODULO expr_pot:ep
            {: arbol nodo = new arbol("OPERACION", "%");
               nodo.agregarHijo(em);
               nodo.agregarHijo(ep);
               // ANÁLISIS SEMÁNTICO: Validar tipos numéricos (int)
               String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(em);
               String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ep);
               AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "%");
               RESULT = nodo; :}
            | expr_pot:ep
            {: RESULT = ep; :}
            ;

expr_pot ::= expr_un:eu POTENCIA expr_pot:ep
           {: arbol nodo = new arbol("OPERACION", "^");
              nodo.agregarHijo(eu);
              nodo.agregarHijo(ep);
              // ANÁLISIS SEMÁNTICO: Validar tipos numéricos
              String tipoIzq = AnalizadorSemantico.obtenerTipoExpresion(eu);
              String tipoDer = AnalizadorSemantico.obtenerTipoExpresion(ep);
              AnalizadorSemantico.validarCompatibilidadTipos(tipoIzq, tipoDer, "^");
              RESULT = nodo; :}
           | expr_un:eu
           {: RESULT = eu; :}
           ;

expr_un ::= RESTA expr_un:eu
          {: arbol nodo = new arbol("OPERACION", "-");
             nodo.agregarHijo(eu);
             RESULT = nodo; :}
          | INC expr_un:eu
          {: arbol nodo = new arbol("OPERACION", "++");
             nodo.agregarHijo(eu);
             RESULT = nodo; :}
          | DEC expr_un:eu
          {: arbol nodo = new arbol("OPERACION", "--");
             nodo.agregarHijo(eu);
             RESULT = nodo; :}
          | NOT expr_un:eu
          {: arbol nodo = new arbol("OPERACION", "NOT");
             nodo.agregarHijo(eu);
             RESULT = nodo; :}
          | prim:p
          {: RESULT = p; :}
          | prim:p INC
          {: arbol nodo = new arbol("OPERACION", "++");
             nodo.agregarHijo(p);
             RESULT = nodo; :}
          | prim:p DEC
          {: arbol nodo = new arbol("OPERACION", "--");
             nodo.agregarHijo(p);
             RESULT = nodo; :}
          ;

prim ::= INT_LIT:n
       {: RESULT = new arbol("LITERAL_INT", n.toString()); :}
       | FLOAT_LIT:f
       {: RESULT = new arbol("LITERAL_FLOAT", f.toString()); :}
       | BOOL_LIT:b
       {: RESULT = new arbol("LITERAL_BOOL", b.toString()); :}
       | CHAR_LIT:c
       {: RESULT = new arbol("LITERAL_CHAR", c.toString()); :}
       | STRING_LIT:s
       {: RESULT = new arbol("LITERAL_STRING", s.toString()); :}
       | IDENT:id
       {: arbol nodo = new arbol("IDENT", id.toString());
          // ANÁLISIS SEMÁNTICO: Validar que la variable esté declarada
          if (!AnalizadorSemantico.estaVariableDeclara(id.toString())) {
             util.ErrorHandler.agregarErrorSemantico("Variable no declarada: " + id.toString());
          }
          RESULT = nodo; :}
       | arr_access:aa
       {: RESULT = aa; :}
       | llamada:ll
       {: RESULT = ll; :}
       | PARENTizq expr:e PARENder
       {: RESULT = e; :}
       ;

llamada ::= IDENT:id PARENTizq args:a PARENder
          {: arbol nodo = new arbol("LLAMADA", id.toString());
             if (a != null) nodo.agregarHijo(a);
             // ANÁLISIS SEMÁNTICO: Validar que la función esté declarada
             if (!AnalizadorSemantico.estaFuncionDeclarada(id.toString())) {
                util.ErrorHandler.agregarErrorSemantico("Función no declarada: " + id.toString());
             }
             RESULT = nodo; :}
          ;

args ::= /* empty */
       {: RESULT = null; :}
       | lista_args:la
       {: RESULT = la; :}
       ;

lista_args ::= expr:e
             {: arbol nodo = new arbol("ARGUMENTOS");
                nodo.agregarHijo(e);
                RESULT = nodo; :}
             | lista_args:la COMA expr:e
             {: la.agregarHijo(e);
                RESULT = la; :}
             ;